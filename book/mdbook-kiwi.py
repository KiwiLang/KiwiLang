from __future__ import annotations

from os import path
from PIL import Image
import pathlib
import abc
import typing
import sys
import json
import re


# Log functions
# =============


def clear():
    if path.exists('book/log.txt'):
        with open('book/log.txt', 'w') as f:
            f.write('This log is generated by mdbook-kiwi\n\n')
    if path.exists('book/log.json'):
        with open('book/log.json', 'w') as f:
            f.write('// This log is generated by mdbook-kiwi\n\n')


def log(*objs: typing.Any):
    for obj in objs:
        msg = str(obj)
        with open('book/log.txt', 'a') as f:
            f.write(msg + '\n')


def logJson(obj: typing.Any):
    msg = json.dumps(obj, indent=4, skipkeys=False)
    with open('book/log.json', 'a') as f:
        f.write(msg + '\n')


# Type definitions
# ================

class Context(typing.TypedDict):
    root: str
    """
    The absolute path to the book root
    
    e.g. "/home/user/kiwi"
    """
    config: Config
    """
    The config of the book
    """
    renderer: typing.Literal['html', 'markdown'] | str
    """
    The renderer of the book
    
    Note: it's always "html" for mdbook-kiwi
    """
    mdbook_version: str
    """
    The version of mdbook
    
    e.g. "0.4.30"
    """


class Config(typing.TypedDict):
    """
    Represents the config of the book

    (Declare it by your own)
    """
    pass


class Book(typing.TypedDict):
    """
    Represents a book
    """
    sections: typing.List[ChapterWrapper]
    """
    The sections of the book
    
    e.g. [ChapterWrapper(Chapter(...)), ChapterWrapper(Chapter(...))]
    """
    __non_exhaustive: typing.Any
    """
    Don't use this field, it's used by the mdbook compiler
    """


class ChapterWrapper(typing.TypedDict):
    """
    Represents a chapter wrapper
    """
    Chapter: Chapter
    """
    The chapter itself
    """


class Chapter(typing.TypedDict):
    """
    Represents a chapter in the book. (Can be a section or a page)
    """
    name: str
    """
    The name of the chapter
    
    e.g. "Basics"
    """
    content: str
    """
    The content of the chapter
    
    e.g. "# Basic syntax\\\\n\\\\nThis is..."
    """
    number: typing.Optional[typing.List[int]]
    """
    The number of the chapter (None if it's top-level)
    
    e.g. [1, 2]
    """
    sub_items: typing.List[ChapterWrapper]
    """
    The sub-items of the chapter (empty if it's a page)
    
    e.g. [ChapterWrapper(Chapter(...)), ChapterWrapper(Chapter(...))]
    """
    path: str
    """
    The relative path from the book root to the chapter
    """
    source_path: str
    """
    The same as `path`
    """
    parent_names: typing.List[str]
    """
    Represents location of the chapter in the book from top to bottom
    
    e.g. ["Basics", "Basic syntax"]
    """


# Preprocessor base
# =================


class Preprocessor(abc.ABC):
    context: Context
    book: Book
    src_path: pathlib.Path
    relative_path: pathlib.Path
    absolute_path: pathlib.Path
    depth: int = 0

    @classmethod
    @abc.abstractmethod
    def make(cls, content: str) -> str:
        """
        Returns the processed content
        """
        ...

    @classmethod
    def iterate(cls, chapterWrapper: ChapterWrapper):
        """
        Iterates through the chapter and preprocesses it
        """
        page = chapterWrapper['Chapter']
        if page['content']:
            cls.relative_path = pathlib.Path(page['path'])
            cls.absolute_path = cls.src_path / cls.relative_path
            page['content'] = cls.make(page['content'])
        for sub_item in page['sub_items']:
            cls.depth += 1
            cls.iterate(sub_item)
            cls.depth -= 1

    @classmethod
    def preprocess(cls, context: Context, book: Book):
        """
        Preprocesses the chapter
        """
        cls.context = context
        cls.book = book
        cls.src_path = pathlib.Path(context['root']) / 'src'
        for obj in book['sections']:
            cls.iterate(obj)


# Preprocessors
# =============


class DocsCardPreprocessor(Preprocessor):
    """
    This preprocessor is used to replace docs-card code blocks with the
    container that allows to display cards with links to other pages.
    """

    class Options(typing.TypedDict):
        title: str
        link: str
        icon: typing.Optional[str]
        text: typing.Optional[str]
        mono: str

    @classmethod
    def replace(cls, match: re.Match) -> str:
        cards: typing.List[str] = []
        for docs_card in re.findall(
                r'```docs-card(.*?)```',
                match.group(),
                flags=re.DOTALL
        ):
            options = cls.Options(
                title="Title (override this)",
                link="",
                icon=None,
                text=None,
                mono="false"
            )

            def replace(context: re.Match) -> str:
                if len(context.groups()) == 1:
                    return context.group()
                for option in re.findall("([a-zA-Z0-9_]+) *= *\"((\\.|[^\"])*)\"", context.group()):
                    if option[0] not in options.keys():
                        raise Exception(f"Unknown option: {option[0]}")
                    options[option[0]] = option[1]  # noqa
                return list(filter(lambda x: x is not None, context.groups()))[-1]

            content = re.sub(
                "\\s*([a-zA-Z0-9_]+ *= *\"(\\.|[^\"])*\" *\n)+(.*)|(.*)",
                replace,
                docs_card,
                flags=re.DOTALL
            ).strip('\n')
            assert options['mono'] in ['true', 'false'], f'Invalid mono option: {options["mono"]}'
            icon_mode = " icon-mode" if options['mono'] == 'true' else str()
            icon = f'[/img]: {options["icon"]} "72px"\n' if options['icon'] else str()
            span = f'<span>{options["text"]}</span>' if options['text'] else str()
            visit = f'<div class="docs-card-visit{icon_mode}">{icon}{span}</div>\n\n' if icon or span else str()
            cards.append(
                f'<div class="admonition quote docs-card">\n'
                f'<a class="docs-card-link" href="{options["link"]}"></a>\n'
                f'<div class="admonition-title">\n<p>{options["title"]}</p>\n</div>'
                f'{visit}\n\n{content}'
                f'</div>'
            )
        result = f'<div class="docs-card-container">\n\n' + '\n\n'.join(cards) + '\n\n</div>'
        return result

    @classmethod
    def make(cls, content: str) -> str:
        return re.sub(
            r'```docs-card(.*?)```(\s*```docs-card(.*?)```)*',
            cls.replace, content,
            flags=re.DOTALL
        )


class KiwiCommandsPreprocessor(Preprocessor):
    """
    This preprocessor is used to replace kiwi commands with the wrapped ones
    see syntax below:
    `[/<command>]: <args or code>`
    """

    @classmethod
    def replace(cls, match: re.Match) -> str:
        command = match.group(1)
        args = match.group(2).split()
        match command:
            case 'img':
                assert len(args) > 0, 'No image path provided'
                if args[0].startswith('/'):
                    assert (file := (cls.src_path / args[0][1:])).exists(), f'Image not found: {args[0]}'
                else:
                    assert (file := (cls.absolute_path.parent / args[0])).exists(), f'Image not found: {args[0]}'
                result = f'{{{{ #template {args[0]} }}}}'
                for option in args[1:]:
                    if match := re.fullmatch(
                            r'" *(?:(w(?=idth\W)?|h(?=eight\W)?)\w*)?=?(\d+)(%|px)? *"',
                            option,
                            flags=re.DOTALL
                    ):
                        direction: typing.Literal['w', 'h'] = match.group(1)
                        value = int(match.group(2))
                        unit: typing.Optional[str] = match.group(3)
                        if not unit:
                            unit = 'px'
                        if direction is None:
                            if file.suffix == '.svg':
                                width = re.search(r'width="(\d+(?:px|%)?)"', file.read_text()).group(1)
                                height = re.search(r'height="(\d+(?:px|%)?)"', file.read_text()).group(1)
                                assert width == height, f'SVG width and height are not equal: {args[0]}'
                            elif file.suffix in ['.jpg', '.jpeg', '.png', '.bmp', '.gif']:
                                img = Image.open(file)
                                assert img.width == img.height, f'Image width and height are not equal: {args[0]}'
                            else:
                                raise ValueError(f'Unsupported image format: {file.suffix}')
                            return f'<div class="kiwi-image-wrapper" style="width: {value}{unit};' \
                                   f'height: {value}{unit};">{result}</div>'
                        return f'<div class="kiwi-image-wrapper" style="' \
                               f'{"width" if direction == "w" else "height"}: {value}{unit};' \
                               f'{"width" if direction == "h" else "height"}: auto;' \
                               f'">{result}</div>'
                return result
            case _:
                raise ValueError(f'Unknown command: {command}')

    @classmethod
    def make(cls, content: str) -> str:
        return re.sub(
            r'\[/(\w+)]:([^\n]*)',
            cls.replace, content,
            flags=re.DOTALL
        )


class MermaidSwitchPreprocessor(Preprocessor):
    """
    This preprocessor is used to replace mermaid code blocks with the wrapped one,
    that allows to switch between different themes. (Currently only "forest" and "dark" are supported)
    """

    @classmethod
    def replace(cls, match: re.Match) -> str:
        log(f"Replacing match of mermaid code:\n{match.group(0)}")
        themes = {
            'light': 'forest',
            'latte': 'forest',
            'coal': 'dark',
            'macchiato': 'dark',
        }
        blocks = []
        styles = []
        options = match.group(1)
        if re.fullmatch(r' *(\w+: *\w+)?( +\w+: *\w+)*', options) is None:
            log(options)
            raise Exception('Invalid mermaid options')
        for option in re.findall(r'\w+: *\w+', options):
            name = option.split(':')[0].strip()
            value = option.split(':')[1].strip()
            match name:
                case 'side':
                    assert value in ['left', 'right'], f'Invalid side: {value}'
                    styles.append(f'float: {value}')
                case _:
                    raise Exception(f'Invalid mermaid option: {name}')
        code = match.group(2)
        style = f' style=\"{"; ".join(styles)}\"' if styles else ''
        themeMermaids = set(themes.values())
        for themeMermaid, index in zip(themeMermaids, range(len(themeMermaids))):
            className = f' class="mermaid mermaid-inner"' if index != 0 else f' class="mermaid mermaid-outer"'
            themePages = [
                themePageInner for themePageInner, themeMermaidInner in themes.items()
                if themeMermaidInner == themeMermaid
            ]
            blocks.append(f'<pre{style}{className} themes="{",".join(themePages)}">'
                          f'%%{{init: {{\'theme\': \'{themeMermaid}\'}}}}%%\n{code}'
                          f'</pre>')
        return '\n\n'.join(blocks)

    @classmethod
    def make(cls, content: str) -> str:
        return re.sub(
            r'```mermaid([^\n]*)\n(.*?)```',
            cls.replace, content,
            flags=re.DOTALL
        )


class TemplateAbsolutePreprocessor(Preprocessor):
    """
    This preprocessor is used to allow to use absolute paths in templates.
    """

    @classmethod
    def replace(cls, match: re.Match) -> str:
        context = re.search(r'(?<=#template) *[\w./_-]+', match.group()).group().strip()
        if context.startswith('/'):
            context = cls.src_path / context[1:]
            if not context.exists():
                raise Exception(f"Template `{context}` not found")
        elif not pathlib.Path(cls.absolute_path) / context:
            raise Exception(f"Template `{context}` not found")
        return f'{{{{ #template {context} }}}}'

    @classmethod
    def make(cls, content: str) -> str:
        return re.sub(
            r'\{\{ *#template +[\w./_-]+ *}}',
            cls.replace, content,
            flags=re.DOTALL
        )


# Main function
# =============


if __name__ == '__main__':

    # Supports
    # --------

    if len(sys.argv) > 1:
        if sys.argv[1] == "supports":
            sys.exit(0)

    # Context loading
    # ---------------

    clear()
    log("Loading context...")
    bookLoaded: Book
    contextLoaded, bookLoaded = json.load(sys.stdin)
    log("Context loaded")

    # Preprocessing

    log("Preprocessing...")
    DocsCardPreprocessor.preprocess(contextLoaded, bookLoaded)
    KiwiCommandsPreprocessor.preprocess(contextLoaded, bookLoaded)
    MermaidSwitchPreprocessor.preprocess(contextLoaded, bookLoaded)
    TemplateAbsolutePreprocessor.preprocess(contextLoaded, bookLoaded)
    log("Preprocessing finished")

    print(json.dumps(bookLoaded, ensure_ascii=False))
